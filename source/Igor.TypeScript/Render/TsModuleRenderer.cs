using Igor.Text;
using Igor.TypeScript.Model;

namespace Igor.TypeScript.Render
{
    public class TsModuleRenderer : Renderer
    {
        public string FileHeader =>
$@"Author: Igor compiler
Compiler version: {Version.HeaderVersionString}
DO NOT EDIT THIS FILE - it is machine generated";

        public void WriteDoc(string annotation, bool allowSingleDoc = false, int maxWidth = 160)
        {
            if (string.IsNullOrWhiteSpace(annotation))
                return;
            var lines = TextHelper.Lines(annotation);
            if (lines.Length == 1 && allowSingleDoc && annotation.Length < 120)
            {
                Line($"/** {annotation} */");
            }
            else
            {
                Line("/**");
                Comment(annotation, " * ", maxWidth);
                Line(" */");
            }
        }

        public void WriteFile(TsFile file)
        {
            void WriteEnumField(TsEnumField field)
            {
                WriteDoc(field.Annotation, true);
                Line($"{field.Name} = {field.Value},");
            }

            void WriteEnum(TsEnum e)
            {
                WriteDoc(e.Annotation);
                Line($"export enum {e.Name} {{");
                Indent();
                ForEach(e.Fields, WriteEnumField);
                Outdent();
                Line("}");
            }

            void WriteClass(TsClass c)
            {
                WriteDoc(c.Annotation);
                var csImplements = c.Interfaces.Count == 0 ? null : " implements " + c.Interfaces.JoinStrings(", ");
                var csExtends = c.BaseClass == null ? null : " extends " + c.BaseClass;
                var @abstract = c.Abstract ? "abstract" : "";
                var genericArgs = c.GenericArgs == null || c.GenericArgs.Count == 0 ? null : "<" + c.GenericArgs.JoinStrings(", ") + ">";
                Blocks(c.Decorators);
                Line($"export {@abstract} class {c.Name}{genericArgs}{csExtends}{csImplements} {{");
                Indent();
                Blocks(c.Properties);
                Blocks(c.Constructors, true);
                Blocks(c.Functions, true);
                Outdent();
                Line("}");
            }

            void WriteInterface(TsInterface c)
            {
                WriteDoc(c.Annotation);
                var csImplements = c.Interfaces.Count == 0 ? null : " extends " + c.Interfaces.JoinStrings(", ");
                var genericArgs = c.GenericArgs == null || c.GenericArgs.Count == 0 ? null : "<" + c.GenericArgs.JoinStrings(", ") + ">";
                Line($"export interface {c.Name}{genericArgs}{csImplements} {{");
                Indent();
                Blocks(c.Properties);
                Blocks(c.Functions, true);
                Outdent();
                Line("}");
            }

            void WriteNamespace(TsNamespace ns)
            {
                Line($"export namespace {ns.Name} {{");
                Indent();
                ForEach(ns.Declarations, WriteDeclaration, emptyLineDelimiter: true);
                EmptyLine();
                Blocks(ns.Functions, true);
                Outdent();
                Line("}");
            }

            void WriteDeclaration(TsDeclaration decl)
            {
                switch (decl)
                {
                    case TsEnum @enum:
                        WriteEnum(@enum);
                        break;
                    case TsInterface intf:
                        WriteInterface(intf);
                        break;
                    case TsClass cl:
                        WriteClass(cl);
                        break;
                    case TsNamespace ns:
                        WriteNamespace(ns);
                        break;
                }
            }

            Comment(FileHeader, "// ");
            EmptyLine();
            Blocks(file.Imports);
            EmptyLine();
            ForEach(file.RootNamespace.Declarations, WriteDeclaration, emptyLineDelimiter: true);
        }

        protected override EmptyLineMode GetEmptyLineModeBetweenLines(string prev, string next)
        {
            if (prev.EndsWith("{"))
                return EmptyLineMode.Forbid;
            else if (prev.EndsWith(":"))
                return EmptyLineMode.Forbid;
            else if (prev.StartsWith("[") && prev.EndsWith("]"))
                return EmptyLineMode.Forbid;
            else if (next == "else")
                return EmptyLineMode.Forbid;
            else if (next == "}")
                return EmptyLineMode.Forbid;
            else
                return EmptyLineMode.Keep;
        }

        public static string Render(TsFile file)
        {
            var renderer = new TsModuleRenderer { Tab = "    ", RemoveDoubleSpaces = true };
            renderer.WriteFile(file);
            return renderer.Build();
        }
    }
}
