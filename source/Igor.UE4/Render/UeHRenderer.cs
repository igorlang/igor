using System.Collections.Generic;
using Igor.Text;
using Igor.UE4.Model;
using System.Linq;
using System.Text;

namespace Igor.UE4.Render
{
    public class UeHRenderer : UeRenderer
    {
        public string FileHeader =>
                $@"Author: Igor compiler
Compiler version: {Version.HeaderVersionString}
DO NOT EDIT THIS FILE - it is machine generated";

        public void WriteFile(UeHFile file)
        {
            Comment(FileHeader, "// ");
            EmptyLine();
            Line("#pragma once");
            EmptyLine();
            Line("#include \"CoreMinimal.h\"");
            Blocks(file.Includes, inc => $@"#include ""{inc}""");
            if (file.DefaultNamespace.Structs.Any(s => s.UClass || s.UStruct))
                Line($@"#include ""{file.GeneratedIncludeName}""");

            EmptyLine();
            var nsForwards = file.ForwardDeclarations.GroupBy(f => f.Namespace);
            foreach (var group in nsForwards)
            {
                if (group.Key == null)
                {
                    Blocks(group, c => $"{c.Type.ToString().ToLower()} {c.Name};");
                }
                else
                {
                    Line($"namespace {group.Key}");
                    Line("{");
                    Indent();
                    Blocks(group, c => $"{c.Type.ToString().ToLower()} {c.Name};");
                    Outdent();
                    Line("}");
                }
            }
            EmptyLine();
            GenerateNamespace(file.DefaultNamespace);
            ForEach(file.Namespaces, GenerateNamespace, emptyLineDelimiter: true);
        }

        private void GenerateNamespace(UeNamespace n)
        {
            if (n.Name != null)
            {
                Line($"namespace {n.Name}");
                Line("{");
                Indent();
            }
            ForEach(n.Enums, GenerateEnum, emptyLineDelimiter: true);
            EmptyLine();
            ForEach(n.Typedefs, GenerateTypedef, emptyLineDelimiter: true);
            EmptyLine();
            ForEach(n.Structs, GenerateStruct, emptyLineDelimiter: true);
            EmptyLine();
            Blocks(n.Definitions);
            EmptyLine();
            ForEach(n.Namespaces, GenerateNamespace, emptyLineDelimiter: true);
            if (n.Name != null)
            {
                Outdent();
                Line("}");
            }
        }

        private void GenerateEnum(UeEnum e)
        {
            Comment(e.Comment, "// ");
            if (e.UEnum)
                Line($"UENUM({FormatSpecifiers(e)})");
            Line($"enum class {e.Name} : {e.IntType}");
            Line("{");
            Blocks(e.Fields, f => $"{f.Name} = {f.Value}{FormatEnumMeta(f.Meta)}", delimiter: ",");
            Line("};");
        }

        private void GenerateTypedef(UeTypedef e)
        {
            Comment(e.Comment, "// ");
            Line($"typedef {e.Declaration} {e.Name};");
        }

        private void GenerateStructField(UeStructField f)
        {
            Comment(f.Comment, "// ");

            var maybeDefaultValue = f.Value == null ? null : " = " + f.Value;
            if (f.UProperty)
                Line($"UPROPERTY({FormatSpecifiers(f)})");
            Line($"{f.Type} {f.Name}{maybeDefaultValue};");
        }

        private void GenerateFunction(UeFunction f)
        {
            Comment(f.Comment, "// ");
            if (f.UFunction)
                Line($"UFUNCTION({FormatSpecifiers(f)})");
            Line(f.Text.Trim());
        }

        private void GenerateStruct(UeStruct s)
        {
            Comment(s.Comment, "// ");

            var maybeBaseTypes = s.BaseTypes.Any() ? ": " + s.BaseTypes.JoinStrings(", ", t => $"public {t}") : null;
            var structOrClass = s.Type == StructType.Struct ? "struct" : "class";
            var ustruct = s.Type == StructType.Struct && s.UStruct;
            var uclass = s.Type == StructType.Class && s.UClass;
            if (ustruct)
                Line($"USTRUCT({FormatSpecifiers(s)})");
            if (uclass)
                Line($"UCLASS({FormatSpecifiers(s)})");
            if (s.GenericArguments != null)
            {
                Line($"template<{s.GenericArguments.JoinStrings(", ", arg => $"typename {arg}")}>");
            }
            Line($"{structOrClass} {s.ApiMacro} {s.Name} {maybeBaseTypes}");
            Line("{");
            Indent();
            if (ustruct || uclass)
                Line("GENERATED_BODY()");
            Blocks(s.Friends, f => $"friend class {f};");

            foreach (var am in new[] { AccessModifier.Public, AccessModifier.Protected, AccessModifier.Private })
            {
                var fields = s.GetFields(am);
                var structs = s.GetStructs(am);
                var functions = s.GetFunctions(am);
                var typedefs = s.GetTypedefs(am);
                if (fields.Any() || structs.Any() || functions.Any() || typedefs.Any())
                {
                    Outdent();
                    Line(am.ToString().ToLower() + ":");
                    Indent();
                    ForEach(structs, GenerateStruct, true);
                    ForEach(typedefs, GenerateTypedef, true);
                    ForEach(fields, GenerateStructField, true);
                    ForEach(functions, GenerateFunction, true);
                }
            }
            Outdent();
            Line("};");
        }

        public static string Render(UeHFile file)
        {
            var renderer = new UeHRenderer();
            renderer.WriteFile(file);
            return UePostprocess.Postprocess(renderer.Build());
        }

        private static string FormatSpecifiers(UeMacroHost macroHost)
        {
            if (!macroHost.Specifiers.Any() && !macroHost.Meta.Any())
                return string.Empty;
            var specs = macroHost.Specifiers;
            var sb = new StringBuilder();
            var first = true;
            foreach (var pair in macroHost.Specifiers)
            {
                if (first)
                    first = false;
                else
                    sb.Append(", ");
                sb.Append(pair.Key);
                if (pair.Value != null)
                {
                    sb.Append(" = ");
                    sb.AppendFormat(pair.Value.All(char.IsLetterOrDigit) ? pair.Value : pair.Value.Quoted());
                }
            }
            if (macroHost.Meta.Any())
            {
                if (!first)
                    sb.Append(", ");
                sb.Append("meta = (");
                first = true;
                foreach (var pair in macroHost.Meta)
                {
                    if (first)
                        first = false;
                    else
                        sb.Append(", ");
                    sb.Append(pair.Key);
                    if (pair.Value != null)
                    {
                        sb.Append(" = ");
                        sb.AppendFormat(pair.Value.All(char.IsLetterOrDigit) ? pair.Value : pair.Value.Quoted());
                    }
                }
                sb.Append(")");
            }
            return sb.ToString();
        }

        private static string FormatEnumMeta(Dictionary<string, string> meta)
        {
            if (!meta.Any())
                return string.Empty;
            var sb = new StringBuilder();
            sb.Append(" UMETA(");
            bool first = true;
            foreach (var pair in meta)
            {
                if (first)
                    first = false;
                else
                    sb.Append(", ");
                sb.Append(pair.Key);
                if (pair.Value != null)
                {
                    sb.Append(" = ");
                    sb.AppendFormat(pair.Value.All(char.IsLetterOrDigit) ? pair.Value : pair.Value.Quoted());
                }
            }
            sb.Append(")");
            return sb.ToString();
        }
    }
}
