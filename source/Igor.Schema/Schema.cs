// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

using System.Collections.Generic;

using JsonSerializer = Json.Serialization.JsonSerializer;

namespace Igor.Schema
{
    public enum DescriptorKind
    {
        Bool = 1,
        Int = 2,
        Float = 3,
        String = 4,
        Binary = 5,
        List = 6,
        Dict = 7,
        Enum = 8,
        Record = 9,
        Union = 10,
        Key = 11,
        Localized = 12,
        Datetime = 13,
        Json = 14,
        Custom = 15,
        GenericInstance = 16,
        GenericArgument = 17,
    }

    public enum IntTypeName
    {
        Int8 = 1,
        Uint8 = 2,
        Int16 = 3,
        Uint16 = 4,
        Int32 = 5,
        Uint32 = 6,
        Int64 = 7,
        Uint64 = 8,
    }

    public enum FloatTypeName
    {
        Float32 = 1,
        Float64 = 2,
    }

    public enum CustomTypeKind
    {
        Record = 1,
        Variant = 2,
        Enum = 3,
        Union = 4,
    }

    public abstract class Descriptor
    {
        public abstract DescriptorKind Kind { get; }

        public bool Optional { get; }

        public string Help { get; }

        public string EditorKey { get; }

        public IReadOnlyDictionary<string, Json.ImmutableJson> Meta { get; }

        protected Descriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null)
        {
            this.Optional = optional;
            this.Help = help;
            this.EditorKey = editorKey;
            this.Meta = meta;
        }
    }

    public sealed class BoolDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Bool;

        public bool? Default { get; }

        public BoolDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null, bool? @default = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
        }
    }

    public sealed class IntDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Int;

        public int? Default { get; }

        public int? Min { get; }

        public int? Max { get; }

        public IntTypeName? Type { get; }

        public IntDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null, int? @default = null, int? min = null, int? max = null, IntTypeName? type = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
            this.Min = min;
            this.Max = max;
            this.Type = type;
        }
    }

    public sealed class FloatDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Float;

        public double? Default { get; }

        public double? Min { get; }

        public double? Max { get; }

        public FloatTypeName? Type { get; }

        public FloatDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null, double? @default = null, double? min = null, double? max = null, FloatTypeName? type = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
            this.Min = min;
            this.Max = max;
            this.Type = type;
        }
    }

    public sealed class PathOptions
    {
        public string Root { get; }

        public string DefaultPath { get; }

        public string Extension { get; }

        public bool? IncludeExtension { get; }

        public PathOptions(string root = null, string defaultPath = null, string extension = null, bool? includeExtension = null)
        {
            this.Root = root;
            this.DefaultPath = defaultPath;
            this.Extension = extension;
            this.IncludeExtension = includeExtension;
        }
    }

    public sealed class StringDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.String;

        public string Default { get; }

        public bool Multiline { get; }

        public bool NotEmpty { get; }

        public bool? LowCardinality { get; }

        public string Source { get; }

        public PathOptions Path { get; }

        public string Syntax { get; }

        public StringDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null, string @default = null, bool multiline = false, bool notEmpty = false, bool? lowCardinality = null, string source = null, PathOptions path = null, string syntax = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
            this.Multiline = multiline;
            this.NotEmpty = notEmpty;
            this.LowCardinality = lowCardinality;
            this.Source = source;
            this.Path = path;
            this.Syntax = syntax;
        }
    }

    public sealed class BinaryDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Binary;

        public BinaryDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class ListDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.List;

        public Descriptor Element { get; }

        public Json.ImmutableJson Default { get; }

        public ListDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, Descriptor element, Json.ImmutableJson @default = null)
            : base(optional, help, editorKey, meta)
        {
            if (element == null)
                throw new System.ArgumentNullException(nameof(element));

            this.Element = element;
            this.Default = @default;
        }
    }

    public sealed class DictDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Dict;

        public Descriptor Key { get; }

        public Descriptor Value { get; }

        public Json.ImmutableJson Default { get; }

        public DictDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, Descriptor key, Descriptor value, Json.ImmutableJson @default = null)
            : base(optional, help, editorKey, meta)
        {
            if (key == null)
                throw new System.ArgumentNullException(nameof(key));
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            this.Key = key;
            this.Value = value;
            this.Default = @default;
        }
    }

    public sealed class EnumDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Enum;

        public string Name { get; }

        public string Default { get; }

        public EnumDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, string name, string @default = null)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Default = @default;
        }
    }

    public sealed class RecordDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Record;

        public string Name { get; }

        public bool Compact { get; }

        public RecordDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, string name, bool compact = false)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Compact = compact;
        }
    }

    public sealed class UnionDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Union;

        public string Name { get; }

        public bool Compact { get; }

        public UnionDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, string name, bool compact = false)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Compact = compact;
        }
    }

    public sealed class KeyDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Key;

        public string Category { get; }

        public string Interface { get; }

        public KeyDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null, string category = null, string @interface = null)
            : base(optional, help, editorKey, meta)
        {
            this.Category = category;
            this.Interface = @interface;
        }
    }

    public sealed class LocalizedDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Localized;

        public string Name { get; }

        public bool Multiline { get; }

        public LocalizedDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, string name, bool multiline = false)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Multiline = multiline;
        }
    }

    public sealed class DateTimeDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Datetime;

        public DateTimeDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class JsonDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Json;

        public JsonDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class CustomDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Custom;

        public CustomDescriptor(bool optional = false, string help = null, string editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson> meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class GenericInstanceDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.GenericInstance;

        public string Prototype { get; }

        public IReadOnlyList<Descriptor> Arguments { get; }

        public GenericInstanceDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, string prototype, IReadOnlyList<Descriptor> arguments)
            : base(optional, help, editorKey, meta)
        {
            if (prototype == null)
                throw new System.ArgumentNullException(nameof(prototype));
            if (arguments == null)
                throw new System.ArgumentNullException(nameof(arguments));
            this.Prototype = prototype;
            this.Arguments = arguments;
        }
    }

    public sealed class GenericArgumentDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.GenericArgument;

        public string Name { get; }

        public GenericArgumentDescriptor(bool optional, string help, string editorKey, IReadOnlyDictionary<string, Json.ImmutableJson> meta, string name)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));
            this.Name = name;
        }
    }

    public abstract class CustomType
    {
        public abstract CustomTypeKind Kind { get; }

        public IReadOnlyDictionary<string, Json.ImmutableJson> Meta { get; }

        protected CustomType(IReadOnlyDictionary<string, Json.ImmutableJson> meta = null)
        {
            this.Meta = meta;
        }
    }

    public abstract class StructCustomType : CustomType
    {
        public IReadOnlyDictionary<string, Descriptor> Fields { get; }

        public string Parent { get; }

        public IReadOnlyList<string> Interfaces { get; }

        protected StructCustomType(IReadOnlyDictionary<string, Json.ImmutableJson> meta, IReadOnlyDictionary<string, Descriptor> fields, string parent, IReadOnlyList<string> interfaces)
            : base(meta)
        {
            if (fields == null)
                throw new System.ArgumentNullException(nameof(fields));

            if (interfaces == null)
                throw new System.ArgumentNullException(nameof(interfaces));
            this.Fields = fields;
            this.Parent = parent;
            this.Interfaces = interfaces;
        }
    }

    public sealed class RecordCustomType : StructCustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Record;

        public IReadOnlyList<string> GenericArguments { get; }

        public string Group { get; }

        public RecordCustomType(IReadOnlyDictionary<string, Json.ImmutableJson> meta, IReadOnlyDictionary<string, Descriptor> fields, string parent, IReadOnlyList<string> interfaces, IReadOnlyList<string> genericArguments = null, string group = null)
            : base(meta, fields, parent, interfaces)
        {
            if (fields == null)
                throw new System.ArgumentNullException(nameof(fields));

            if (interfaces == null)
                throw new System.ArgumentNullException(nameof(interfaces));

            this.GenericArguments = genericArguments;
            this.Group = group;
        }
    }

    public sealed class VariantCustomType : StructCustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Variant;

        public string Tag { get; }

        public IReadOnlyDictionary<string, string> Children { get; }

        public VariantCustomType(IReadOnlyDictionary<string, Json.ImmutableJson> meta, IReadOnlyDictionary<string, Descriptor> fields, string parent, IReadOnlyList<string> interfaces, string tag, IReadOnlyDictionary<string, string> children)
            : base(meta, fields, parent, interfaces)
        {
            if (fields == null)
                throw new System.ArgumentNullException(nameof(fields));

            if (interfaces == null)
                throw new System.ArgumentNullException(nameof(interfaces));
            if (tag == null)
                throw new System.ArgumentNullException(nameof(tag));
            if (children == null)
                throw new System.ArgumentNullException(nameof(children));
            this.Tag = tag;
            this.Children = children;
        }
    }

    public sealed class EnumCustomType : CustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Enum;

        public IReadOnlyList<string> Values { get; }

        public EnumCustomType(IReadOnlyDictionary<string, Json.ImmutableJson> meta, IReadOnlyList<string> values)
            : base(meta)
        {
            if (values == null)
                throw new System.ArgumentNullException(nameof(values));
            this.Values = values;
        }
    }

    public sealed class UnionCustomType : CustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Union;

        public IReadOnlyDictionary<string, Descriptor> Clauses { get; }

        public IReadOnlyList<string> GenericArguments { get; }

        public UnionCustomType(IReadOnlyDictionary<string, Json.ImmutableJson> meta, IReadOnlyDictionary<string, Descriptor> clauses, IReadOnlyList<string> genericArguments = null)
            : base(meta)
        {
            if (clauses == null)
                throw new System.ArgumentNullException(nameof(clauses));

            this.Clauses = clauses;
            this.GenericArguments = genericArguments;
        }
    }

    public sealed class Schema
    {
        public IReadOnlyDictionary<string, CustomType> CustomTypes { get; }

        public string DocumentType { get; }

        public string Version { get; }

        public Schema(IReadOnlyDictionary<string, CustomType> customTypes, string documentType, string version = "1.0")
        {
            if (customTypes == null)
                throw new System.ArgumentNullException(nameof(customTypes));
            if (documentType == null)
                throw new System.ArgumentNullException(nameof(documentType));
            if (version == null)
                throw new System.ArgumentNullException(nameof(version));
            this.CustomTypes = customTypes;
            this.DocumentType = documentType;
            this.Version = version;
        }
    }

    public sealed class DescriptorKindJsonSerializer : Json.Serialization.IJsonSerializer<DescriptorKind>, Json.Serialization.IJsonKeySerializer<DescriptorKind>
    {
        public static readonly DescriptorKindJsonSerializer Instance = new DescriptorKindJsonSerializer();

        public Json.ImmutableJson Serialize(DescriptorKind value)
        {
            return SerializeKey(value);
        }

        public DescriptorKind Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsString;
        }

        public string SerializeKey(DescriptorKind value)
        {
            switch (value)
            {
                case DescriptorKind.Bool: return "bool";
                case DescriptorKind.Int: return "int";
                case DescriptorKind.Float: return "float";
                case DescriptorKind.String: return "string";
                case DescriptorKind.Binary: return "binary";
                case DescriptorKind.List: return "list";
                case DescriptorKind.Dict: return "dict";
                case DescriptorKind.Enum: return "enum";
                case DescriptorKind.Record: return "record";
                case DescriptorKind.Union: return "union";
                case DescriptorKind.Key: return "key";
                case DescriptorKind.Localized: return "localized";
                case DescriptorKind.Datetime: return "datetime";
                case DescriptorKind.Json: return "json";
                case DescriptorKind.Custom: return "custom";
                case DescriptorKind.GenericInstance: return "generic_instance";
                case DescriptorKind.GenericArgument: return "generic_argument";
                default: throw new System.ArgumentOutOfRangeException(nameof(value));
            }
        }

        public DescriptorKind DeserializeKey(string jsonKey)
        {
            switch (jsonKey)
            {
                case "bool": return DescriptorKind.Bool;
                case "int": return DescriptorKind.Int;
                case "float": return DescriptorKind.Float;
                case "string": return DescriptorKind.String;
                case "binary": return DescriptorKind.Binary;
                case "list": return DescriptorKind.List;
                case "dict": return DescriptorKind.Dict;
                case "enum": return DescriptorKind.Enum;
                case "record": return DescriptorKind.Record;
                case "union": return DescriptorKind.Union;
                case "key": return DescriptorKind.Key;
                case "localized": return DescriptorKind.Localized;
                case "datetime": return DescriptorKind.Datetime;
                case "json": return DescriptorKind.Json;
                case "custom": return DescriptorKind.Custom;
                case "generic_instance": return DescriptorKind.GenericInstance;
                case "generic_argument": return DescriptorKind.GenericArgument;
                default: throw new System.ArgumentOutOfRangeException(nameof(jsonKey));
            }
        }
    }

    public sealed class DescriptorJsonSerializer : Json.Serialization.IJsonSerializer<Descriptor>
    {
        public static readonly DescriptorJsonSerializer Instance = new DescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(Descriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            switch (value.Kind)
            {
                case DescriptorKind.Bool: return BoolDescriptorJsonSerializer.Instance.Serialize((BoolDescriptor)value);
                case DescriptorKind.Int: return IntDescriptorJsonSerializer.Instance.Serialize((IntDescriptor)value);
                case DescriptorKind.Float: return FloatDescriptorJsonSerializer.Instance.Serialize((FloatDescriptor)value);
                case DescriptorKind.String: return StringDescriptorJsonSerializer.Instance.Serialize((StringDescriptor)value);
                case DescriptorKind.Binary: return BinaryDescriptorJsonSerializer.Instance.Serialize((BinaryDescriptor)value);
                case DescriptorKind.List: return ListDescriptorJsonSerializer.Instance.Serialize((ListDescriptor)value);
                case DescriptorKind.Dict: return DictDescriptorJsonSerializer.Instance.Serialize((DictDescriptor)value);
                case DescriptorKind.Enum: return EnumDescriptorJsonSerializer.Instance.Serialize((EnumDescriptor)value);
                case DescriptorKind.Record: return RecordDescriptorJsonSerializer.Instance.Serialize((RecordDescriptor)value);
                case DescriptorKind.Union: return UnionDescriptorJsonSerializer.Instance.Serialize((UnionDescriptor)value);
                case DescriptorKind.Key: return KeyDescriptorJsonSerializer.Instance.Serialize((KeyDescriptor)value);
                case DescriptorKind.Localized: return LocalizedDescriptorJsonSerializer.Instance.Serialize((LocalizedDescriptor)value);
                case DescriptorKind.Datetime: return DateTimeDescriptorJsonSerializer.Instance.Serialize((DateTimeDescriptor)value);
                case DescriptorKind.Json: return JsonDescriptorJsonSerializer.Instance.Serialize((JsonDescriptor)value);
                case DescriptorKind.Custom: return CustomDescriptorJsonSerializer.Instance.Serialize((CustomDescriptor)value);
                case DescriptorKind.GenericInstance: return GenericInstanceDescriptorJsonSerializer.Instance.Serialize((GenericInstanceDescriptor)value);
                case DescriptorKind.GenericArgument: return GenericArgumentDescriptorJsonSerializer.Instance.Serialize((GenericArgumentDescriptor)value);
                default: throw new System.ArgumentException("Invalid variant tag");
            }
        }

        public Descriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            DescriptorKind kind = DescriptorKindJsonSerializer.Instance.Deserialize(json["kind"]);
            switch (kind)
            {
                case DescriptorKind.Bool: return BoolDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Int: return IntDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Float: return FloatDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.String: return StringDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Binary: return BinaryDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.List: return ListDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Dict: return DictDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Enum: return EnumDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Record: return RecordDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Union: return UnionDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Key: return KeyDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Localized: return LocalizedDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Datetime: return DateTimeDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Json: return JsonDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.Custom: return CustomDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.GenericInstance: return GenericInstanceDescriptorJsonSerializer.Instance.Deserialize(json);
                case DescriptorKind.GenericArgument: return GenericArgumentDescriptorJsonSerializer.Instance.Deserialize(json);
                default: throw new System.ArgumentException("Invalid variant tag");
            }
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject && json.AsObject.ContainsKey("kind");
        }
    }

    public sealed class BoolDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<BoolDescriptor>
    {
        public static readonly BoolDescriptorJsonSerializer Instance = new BoolDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(BoolDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default.HasValue)
                json["default"] = JsonSerializer.Bool.Serialize(value.Default.Value);
            return json;
        }

        public BoolDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            bool? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Bool.Deserialize(jsonDefault);
            else
                @default = null;
            return new BoolDescriptor(optional, help, editorKey, meta, @default);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class IntTypeNameJsonSerializer : Json.Serialization.IJsonSerializer<IntTypeName>, Json.Serialization.IJsonKeySerializer<IntTypeName>
    {
        public static readonly IntTypeNameJsonSerializer Instance = new IntTypeNameJsonSerializer();

        public Json.ImmutableJson Serialize(IntTypeName value)
        {
            return SerializeKey(value);
        }

        public IntTypeName Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsString;
        }

        public string SerializeKey(IntTypeName value)
        {
            switch (value)
            {
                case IntTypeName.Int8: return "int8";
                case IntTypeName.Uint8: return "uint8";
                case IntTypeName.Int16: return "int16";
                case IntTypeName.Uint16: return "uint16";
                case IntTypeName.Int32: return "int32";
                case IntTypeName.Uint32: return "uint32";
                case IntTypeName.Int64: return "int64";
                case IntTypeName.Uint64: return "uint64";
                default: throw new System.ArgumentOutOfRangeException(nameof(value));
            }
        }

        public IntTypeName DeserializeKey(string jsonKey)
        {
            switch (jsonKey)
            {
                case "int8": return IntTypeName.Int8;
                case "uint8": return IntTypeName.Uint8;
                case "int16": return IntTypeName.Int16;
                case "uint16": return IntTypeName.Uint16;
                case "int32": return IntTypeName.Int32;
                case "uint32": return IntTypeName.Uint32;
                case "int64": return IntTypeName.Int64;
                case "uint64": return IntTypeName.Uint64;
                default: throw new System.ArgumentOutOfRangeException(nameof(jsonKey));
            }
        }
    }

    public sealed class IntDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<IntDescriptor>
    {
        public static readonly IntDescriptorJsonSerializer Instance = new IntDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(IntDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default.HasValue)
                json["default"] = JsonSerializer.Int.Serialize(value.Default.Value);
            if (value.Min.HasValue)
                json["min"] = JsonSerializer.Int.Serialize(value.Min.Value);
            if (value.Max.HasValue)
                json["max"] = JsonSerializer.Int.Serialize(value.Max.Value);
            if (value.Type.HasValue)
                json["type"] = IntTypeNameJsonSerializer.Instance.Serialize(value.Type.Value);
            return json;
        }

        public IntDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            int? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Int.Deserialize(jsonDefault);
            else
                @default = null;
            int? min;
            if (json.AsObject.TryGetValue("min", out var jsonMin) && !jsonMin.IsNull)
                min = JsonSerializer.Int.Deserialize(jsonMin);
            else
                min = null;
            int? max;
            if (json.AsObject.TryGetValue("max", out var jsonMax) && !jsonMax.IsNull)
                max = JsonSerializer.Int.Deserialize(jsonMax);
            else
                max = null;
            IntTypeName? type;
            if (json.AsObject.TryGetValue("type", out var jsonType) && !jsonType.IsNull)
                type = IntTypeNameJsonSerializer.Instance.Deserialize(jsonType);
            else
                type = null;
            return new IntDescriptor(optional, help, editorKey, meta, @default, min, max, type);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class FloatTypeNameJsonSerializer : Json.Serialization.IJsonSerializer<FloatTypeName>, Json.Serialization.IJsonKeySerializer<FloatTypeName>
    {
        public static readonly FloatTypeNameJsonSerializer Instance = new FloatTypeNameJsonSerializer();

        public Json.ImmutableJson Serialize(FloatTypeName value)
        {
            return SerializeKey(value);
        }

        public FloatTypeName Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsString;
        }

        public string SerializeKey(FloatTypeName value)
        {
            switch (value)
            {
                case FloatTypeName.Float32: return "float32";
                case FloatTypeName.Float64: return "float64";
                default: throw new System.ArgumentOutOfRangeException(nameof(value));
            }
        }

        public FloatTypeName DeserializeKey(string jsonKey)
        {
            switch (jsonKey)
            {
                case "float32": return FloatTypeName.Float32;
                case "float64": return FloatTypeName.Float64;
                default: throw new System.ArgumentOutOfRangeException(nameof(jsonKey));
            }
        }
    }

    public sealed class FloatDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<FloatDescriptor>
    {
        public static readonly FloatDescriptorJsonSerializer Instance = new FloatDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(FloatDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default.HasValue)
                json["default"] = JsonSerializer.Double.Serialize(value.Default.Value);
            if (value.Min.HasValue)
                json["min"] = JsonSerializer.Double.Serialize(value.Min.Value);
            if (value.Max.HasValue)
                json["max"] = JsonSerializer.Double.Serialize(value.Max.Value);
            if (value.Type.HasValue)
                json["type"] = FloatTypeNameJsonSerializer.Instance.Serialize(value.Type.Value);
            return json;
        }

        public FloatDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            double? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Double.Deserialize(jsonDefault);
            else
                @default = null;
            double? min;
            if (json.AsObject.TryGetValue("min", out var jsonMin) && !jsonMin.IsNull)
                min = JsonSerializer.Double.Deserialize(jsonMin);
            else
                min = null;
            double? max;
            if (json.AsObject.TryGetValue("max", out var jsonMax) && !jsonMax.IsNull)
                max = JsonSerializer.Double.Deserialize(jsonMax);
            else
                max = null;
            FloatTypeName? type;
            if (json.AsObject.TryGetValue("type", out var jsonType) && !jsonType.IsNull)
                type = FloatTypeNameJsonSerializer.Instance.Deserialize(jsonType);
            else
                type = null;
            return new FloatDescriptor(optional, help, editorKey, meta, @default, min, max, type);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class PathOptionsJsonSerializer : Json.Serialization.IJsonSerializer<PathOptions>
    {
        public static readonly PathOptionsJsonSerializer Instance = new PathOptionsJsonSerializer();

        public Json.ImmutableJson Serialize(PathOptions value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            if (value.Root != null)
                json["root"] = JsonSerializer.String.Serialize(value.Root);
            if (value.DefaultPath != null)
                json["default_path"] = JsonSerializer.String.Serialize(value.DefaultPath);
            if (value.Extension != null)
                json["extension"] = JsonSerializer.String.Serialize(value.Extension);
            if (value.IncludeExtension.HasValue)
                json["include_extension"] = JsonSerializer.Bool.Serialize(value.IncludeExtension.Value);
            return json;
        }

        public PathOptions Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            string root;
            if (json.AsObject.TryGetValue("root", out var jsonRoot) && !jsonRoot.IsNull)
                root = JsonSerializer.String.Deserialize(jsonRoot);
            else
                root = null;
            string defaultPath;
            if (json.AsObject.TryGetValue("default_path", out var jsonDefaultPath) && !jsonDefaultPath.IsNull)
                defaultPath = JsonSerializer.String.Deserialize(jsonDefaultPath);
            else
                defaultPath = null;
            string extension;
            if (json.AsObject.TryGetValue("extension", out var jsonExtension) && !jsonExtension.IsNull)
                extension = JsonSerializer.String.Deserialize(jsonExtension);
            else
                extension = null;
            bool? includeExtension;
            if (json.AsObject.TryGetValue("include_extension", out var jsonIncludeExtension) && !jsonIncludeExtension.IsNull)
                includeExtension = JsonSerializer.Bool.Deserialize(jsonIncludeExtension);
            else
                includeExtension = null;
            return new PathOptions(root, defaultPath, extension, includeExtension);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class StringDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<StringDescriptor>
    {
        public static readonly StringDescriptorJsonSerializer Instance = new StringDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(StringDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default != null)
                json["default"] = JsonSerializer.String.Serialize(value.Default);
            json["multiline"] = JsonSerializer.Bool.Serialize(value.Multiline);
            json["not_empty"] = JsonSerializer.Bool.Serialize(value.NotEmpty);
            if (value.LowCardinality.HasValue)
                json["low_cardinality"] = JsonSerializer.Bool.Serialize(value.LowCardinality.Value);
            if (value.Source != null)
                json["source"] = JsonSerializer.String.Serialize(value.Source);
            if (value.Path != null)
                json["path"] = PathOptionsJsonSerializer.Instance.Serialize(value.Path);
            if (value.Syntax != null)
                json["syntax"] = JsonSerializer.String.Serialize(value.Syntax);
            return json;
        }

        public StringDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            string @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.String.Deserialize(jsonDefault);
            else
                @default = null;
            bool multiline;
            if (json.AsObject.TryGetValue("multiline", out var jsonMultiline) && !jsonMultiline.IsNull)
                multiline = JsonSerializer.Bool.Deserialize(jsonMultiline);
            else
                multiline = false;
            bool notEmpty;
            if (json.AsObject.TryGetValue("not_empty", out var jsonNotEmpty) && !jsonNotEmpty.IsNull)
                notEmpty = JsonSerializer.Bool.Deserialize(jsonNotEmpty);
            else
                notEmpty = false;
            bool? lowCardinality;
            if (json.AsObject.TryGetValue("low_cardinality", out var jsonLowCardinality) && !jsonLowCardinality.IsNull)
                lowCardinality = JsonSerializer.Bool.Deserialize(jsonLowCardinality);
            else
                lowCardinality = null;
            string source;
            if (json.AsObject.TryGetValue("source", out var jsonSource) && !jsonSource.IsNull)
                source = JsonSerializer.String.Deserialize(jsonSource);
            else
                source = null;
            PathOptions path;
            if (json.AsObject.TryGetValue("path", out var jsonPath) && !jsonPath.IsNull)
                path = PathOptionsJsonSerializer.Instance.Deserialize(jsonPath);
            else
                path = null;
            string syntax;
            if (json.AsObject.TryGetValue("syntax", out var jsonSyntax) && !jsonSyntax.IsNull)
                syntax = JsonSerializer.String.Deserialize(jsonSyntax);
            else
                syntax = null;
            return new StringDescriptor(optional, help, editorKey, meta, @default, multiline, notEmpty, lowCardinality, source, path, syntax);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class BinaryDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<BinaryDescriptor>
    {
        public static readonly BinaryDescriptorJsonSerializer Instance = new BinaryDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(BinaryDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public BinaryDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new BinaryDescriptor(optional, help, editorKey, meta);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class ListDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<ListDescriptor>
    {
        public static readonly ListDescriptorJsonSerializer Instance = new ListDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(ListDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Element == null)
                throw new System.ArgumentException("Required property Element is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["element"] = DescriptorJsonSerializer.Instance.Serialize(value.Element);
            if (value.Default != null)
                json["default"] = JsonSerializer.Json.Serialize(value.Default);
            return json;
        }

        public ListDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var element = DescriptorJsonSerializer.Instance.Deserialize(json["element"]);
            Json.ImmutableJson @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Json.Deserialize(jsonDefault);
            else
                @default = null;
            return new ListDescriptor(optional, help, editorKey, meta, element, @default);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class DictDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<DictDescriptor>
    {
        public static readonly DictDescriptorJsonSerializer Instance = new DictDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(DictDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Key == null)
                throw new System.ArgumentException("Required property Key is null", nameof(value));
            if (value.Value == null)
                throw new System.ArgumentException("Required property Value is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["key"] = DescriptorJsonSerializer.Instance.Serialize(value.Key);
            json["value"] = DescriptorJsonSerializer.Instance.Serialize(value.Value);
            if (value.Default != null)
                json["default"] = JsonSerializer.Json.Serialize(value.Default);
            return json;
        }

        public DictDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var key = DescriptorJsonSerializer.Instance.Deserialize(json["key"]);
            var value = DescriptorJsonSerializer.Instance.Deserialize(json["value"]);
            Json.ImmutableJson @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Json.Deserialize(jsonDefault);
            else
                @default = null;
            return new DictDescriptor(optional, help, editorKey, meta, key, value, @default);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class EnumDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<EnumDescriptor>
    {
        public static readonly EnumDescriptorJsonSerializer Instance = new EnumDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(EnumDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            if (value.Default != null)
                json["default"] = JsonSerializer.String.Serialize(value.Default);
            return json;
        }

        public EnumDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            string @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.String.Deserialize(jsonDefault);
            else
                @default = null;
            return new EnumDescriptor(optional, help, editorKey, meta, name, @default);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class RecordDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<RecordDescriptor>
    {
        public static readonly RecordDescriptorJsonSerializer Instance = new RecordDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(RecordDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            json["compact"] = JsonSerializer.Bool.Serialize(value.Compact);
            return json;
        }

        public RecordDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            bool compact;
            if (json.AsObject.TryGetValue("compact", out var jsonCompact) && !jsonCompact.IsNull)
                compact = JsonSerializer.Bool.Deserialize(jsonCompact);
            else
                compact = false;
            return new RecordDescriptor(optional, help, editorKey, meta, name, compact);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class UnionDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<UnionDescriptor>
    {
        public static readonly UnionDescriptorJsonSerializer Instance = new UnionDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(UnionDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            json["compact"] = JsonSerializer.Bool.Serialize(value.Compact);
            return json;
        }

        public UnionDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            bool compact;
            if (json.AsObject.TryGetValue("compact", out var jsonCompact) && !jsonCompact.IsNull)
                compact = JsonSerializer.Bool.Deserialize(jsonCompact);
            else
                compact = false;
            return new UnionDescriptor(optional, help, editorKey, meta, name, compact);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class KeyDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<KeyDescriptor>
    {
        public static readonly KeyDescriptorJsonSerializer Instance = new KeyDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(KeyDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Category != null)
                json["category"] = JsonSerializer.String.Serialize(value.Category);
            if (value.Interface != null)
                json["interface"] = JsonSerializer.String.Serialize(value.Interface);
            return json;
        }

        public KeyDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            string category;
            if (json.AsObject.TryGetValue("category", out var jsonCategory) && !jsonCategory.IsNull)
                category = JsonSerializer.String.Deserialize(jsonCategory);
            else
                category = null;
            string @interface;
            if (json.AsObject.TryGetValue("interface", out var jsonInterface) && !jsonInterface.IsNull)
                @interface = JsonSerializer.String.Deserialize(jsonInterface);
            else
                @interface = null;
            return new KeyDescriptor(optional, help, editorKey, meta, category, @interface);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class LocalizedDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<LocalizedDescriptor>
    {
        public static readonly LocalizedDescriptorJsonSerializer Instance = new LocalizedDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(LocalizedDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            json["multiline"] = JsonSerializer.Bool.Serialize(value.Multiline);
            return json;
        }

        public LocalizedDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            bool multiline;
            if (json.AsObject.TryGetValue("multiline", out var jsonMultiline) && !jsonMultiline.IsNull)
                multiline = JsonSerializer.Bool.Deserialize(jsonMultiline);
            else
                multiline = false;
            return new LocalizedDescriptor(optional, help, editorKey, meta, name, multiline);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class DateTimeDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<DateTimeDescriptor>
    {
        public static readonly DateTimeDescriptorJsonSerializer Instance = new DateTimeDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(DateTimeDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public DateTimeDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new DateTimeDescriptor(optional, help, editorKey, meta);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class JsonDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<JsonDescriptor>
    {
        public static readonly JsonDescriptorJsonSerializer Instance = new JsonDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(JsonDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public JsonDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new JsonDescriptor(optional, help, editorKey, meta);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class CustomDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<CustomDescriptor>
    {
        public static readonly CustomDescriptorJsonSerializer Instance = new CustomDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(CustomDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public CustomDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new CustomDescriptor(optional, help, editorKey, meta);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class GenericInstanceDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<GenericInstanceDescriptor>
    {
        public static readonly GenericInstanceDescriptorJsonSerializer Instance = new GenericInstanceDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(GenericInstanceDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Prototype == null)
                throw new System.ArgumentException("Required property Prototype is null", nameof(value));
            if (value.Arguments == null)
                throw new System.ArgumentException("Required property Arguments is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["prototype"] = JsonSerializer.String.Serialize(value.Prototype);
            json["arguments"] = JsonSerializer.ReadOnlyList(DescriptorJsonSerializer.Instance).Serialize(value.Arguments);
            return json;
        }

        public GenericInstanceDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var prototype = JsonSerializer.String.Deserialize(json["prototype"]);
            var arguments = JsonSerializer.ReadOnlyList(DescriptorJsonSerializer.Instance).Deserialize(json["arguments"]);
            return new GenericInstanceDescriptor(optional, help, editorKey, meta, prototype, arguments);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class GenericArgumentDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<GenericArgumentDescriptor>
    {
        public static readonly GenericArgumentDescriptorJsonSerializer Instance = new GenericArgumentDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(GenericArgumentDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            return json;
        }

        public GenericArgumentDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            return new GenericArgumentDescriptor(optional, help, editorKey, meta, name);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class CustomTypeKindJsonSerializer : Json.Serialization.IJsonSerializer<CustomTypeKind>, Json.Serialization.IJsonKeySerializer<CustomTypeKind>
    {
        public static readonly CustomTypeKindJsonSerializer Instance = new CustomTypeKindJsonSerializer();

        public Json.ImmutableJson Serialize(CustomTypeKind value)
        {
            return SerializeKey(value);
        }

        public CustomTypeKind Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsString;
        }

        public string SerializeKey(CustomTypeKind value)
        {
            switch (value)
            {
                case CustomTypeKind.Record: return "record";
                case CustomTypeKind.Variant: return "variant";
                case CustomTypeKind.Enum: return "enum";
                case CustomTypeKind.Union: return "union";
                default: throw new System.ArgumentOutOfRangeException(nameof(value));
            }
        }

        public CustomTypeKind DeserializeKey(string jsonKey)
        {
            switch (jsonKey)
            {
                case "record": return CustomTypeKind.Record;
                case "variant": return CustomTypeKind.Variant;
                case "enum": return CustomTypeKind.Enum;
                case "union": return CustomTypeKind.Union;
                default: throw new System.ArgumentOutOfRangeException(nameof(jsonKey));
            }
        }
    }

    public sealed class CustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<CustomType>
    {
        public static readonly CustomTypeJsonSerializer Instance = new CustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(CustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            switch (value.Kind)
            {
                case CustomTypeKind.Record: return RecordCustomTypeJsonSerializer.Instance.Serialize((RecordCustomType)value);
                case CustomTypeKind.Variant: return VariantCustomTypeJsonSerializer.Instance.Serialize((VariantCustomType)value);
                case CustomTypeKind.Enum: return EnumCustomTypeJsonSerializer.Instance.Serialize((EnumCustomType)value);
                case CustomTypeKind.Union: return UnionCustomTypeJsonSerializer.Instance.Serialize((UnionCustomType)value);
                default: throw new System.ArgumentException("Invalid variant tag");
            }
        }

        public CustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            CustomTypeKind kind = CustomTypeKindJsonSerializer.Instance.Deserialize(json["kind"]);
            switch (kind)
            {
                case CustomTypeKind.Record: return RecordCustomTypeJsonSerializer.Instance.Deserialize(json);
                case CustomTypeKind.Variant: return VariantCustomTypeJsonSerializer.Instance.Deserialize(json);
                case CustomTypeKind.Enum: return EnumCustomTypeJsonSerializer.Instance.Deserialize(json);
                case CustomTypeKind.Union: return UnionCustomTypeJsonSerializer.Instance.Deserialize(json);
                default: throw new System.ArgumentException("Invalid variant tag");
            }
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject && json.AsObject.ContainsKey("kind");
        }
    }

    public sealed class StructCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<StructCustomType>
    {
        public static readonly StructCustomTypeJsonSerializer Instance = new StructCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(StructCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            switch (value.Kind)
            {
                case CustomTypeKind.Record: return RecordCustomTypeJsonSerializer.Instance.Serialize((RecordCustomType)value);
                case CustomTypeKind.Variant: return VariantCustomTypeJsonSerializer.Instance.Serialize((VariantCustomType)value);
                default: throw new System.ArgumentException("Invalid variant tag");
            }
        }

        public StructCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            CustomTypeKind kind = CustomTypeKindJsonSerializer.Instance.Deserialize(json["kind"]);
            switch (kind)
            {
                case CustomTypeKind.Record: return RecordCustomTypeJsonSerializer.Instance.Deserialize(json);
                case CustomTypeKind.Variant: return VariantCustomTypeJsonSerializer.Instance.Deserialize(json);
                default: throw new System.ArgumentException("Invalid variant tag");
            }
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject && json.AsObject.ContainsKey("kind");
        }
    }

    public sealed class RecordCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<RecordCustomType>
    {
        public static readonly RecordCustomTypeJsonSerializer Instance = new RecordCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(RecordCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Fields == null)
                throw new System.ArgumentException("Required property Fields is null", nameof(value));

            if (value.Interfaces == null)
                throw new System.ArgumentException("Required property Interfaces is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["fields"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Serialize(value.Fields);
            if (value.Parent != null)
                json["parent"] = JsonSerializer.String.Serialize(value.Parent);
            json["interfaces"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.Interfaces);
            if (value.GenericArguments != null)
                json["generic_arguments"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.GenericArguments);
            if (value.Group != null)
                json["group"] = JsonSerializer.String.Serialize(value.Group);
            return json;
        }

        public RecordCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var fields = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Deserialize(json["fields"]);
            string parent;
            if (json.AsObject.TryGetValue("parent", out var jsonParent) && !jsonParent.IsNull)
                parent = JsonSerializer.String.Deserialize(jsonParent);
            else
                parent = null;
            var interfaces = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(json["interfaces"]);
            IReadOnlyList<string> genericArguments;
            if (json.AsObject.TryGetValue("generic_arguments", out var jsonGenericArguments) && !jsonGenericArguments.IsNull)
                genericArguments = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(jsonGenericArguments);
            else
                genericArguments = null;
            string group;
            if (json.AsObject.TryGetValue("group", out var jsonGroup) && !jsonGroup.IsNull)
                group = JsonSerializer.String.Deserialize(jsonGroup);
            else
                group = null;
            return new RecordCustomType(meta, fields, parent, interfaces, genericArguments, group);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class VariantCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<VariantCustomType>
    {
        public static readonly VariantCustomTypeJsonSerializer Instance = new VariantCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(VariantCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Fields == null)
                throw new System.ArgumentException("Required property Fields is null", nameof(value));

            if (value.Interfaces == null)
                throw new System.ArgumentException("Required property Interfaces is null", nameof(value));
            if (value.Tag == null)
                throw new System.ArgumentException("Required property Tag is null", nameof(value));
            if (value.Children == null)
                throw new System.ArgumentException("Required property Children is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["fields"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Serialize(value.Fields);
            if (value.Parent != null)
                json["parent"] = JsonSerializer.String.Serialize(value.Parent);
            json["interfaces"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.Interfaces);
            json["tag"] = JsonSerializer.String.Serialize(value.Tag);
            json["children"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.String).Serialize(value.Children);
            return json;
        }

        public VariantCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var fields = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Deserialize(json["fields"]);
            string parent;
            if (json.AsObject.TryGetValue("parent", out var jsonParent) && !jsonParent.IsNull)
                parent = JsonSerializer.String.Deserialize(jsonParent);
            else
                parent = null;
            var interfaces = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(json["interfaces"]);
            var tag = JsonSerializer.String.Deserialize(json["tag"]);
            var children = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.String).Deserialize(json["children"]);
            return new VariantCustomType(meta, fields, parent, interfaces, tag, children);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class EnumCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<EnumCustomType>
    {
        public static readonly EnumCustomTypeJsonSerializer Instance = new EnumCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(EnumCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Values == null)
                throw new System.ArgumentException("Required property Values is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["values"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.Values);
            return json;
        }

        public EnumCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var values = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(json["values"]);
            return new EnumCustomType(meta, values);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class UnionCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<UnionCustomType>
    {
        public static readonly UnionCustomTypeJsonSerializer Instance = new UnionCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(UnionCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Clauses == null)
                throw new System.ArgumentException("Required property Clauses is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["clauses"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Optional(DescriptorJsonSerializer.Instance)).Serialize(value.Clauses);
            if (value.GenericArguments != null)
                json["generic_arguments"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.GenericArguments);
            return json;
        }

        public UnionCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson> meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var clauses = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Optional(DescriptorJsonSerializer.Instance)).Deserialize(json["clauses"]);
            IReadOnlyList<string> genericArguments;
            if (json.AsObject.TryGetValue("generic_arguments", out var jsonGenericArguments) && !jsonGenericArguments.IsNull)
                genericArguments = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(jsonGenericArguments);
            else
                genericArguments = null;
            return new UnionCustomType(meta, clauses, genericArguments);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }

    public sealed class SchemaJsonSerializer : Json.Serialization.IJsonSerializer<Schema>
    {
        public static readonly SchemaJsonSerializer Instance = new SchemaJsonSerializer();

        public Json.ImmutableJson Serialize(Schema value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            if (value.CustomTypes == null)
                throw new System.ArgumentException("Required property CustomTypes is null", nameof(value));
            if (value.DocumentType == null)
                throw new System.ArgumentException("Required property DocumentType is null", nameof(value));
            if (value.Version == null)
                throw new System.ArgumentException("Required property Version is null", nameof(value));
            return new Json.JsonObject
            {
                ["custom_types"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, CustomTypeJsonSerializer.Instance).Serialize(value.CustomTypes),
                ["document_type"] = JsonSerializer.String.Serialize(value.DocumentType),
                ["version"] = JsonSerializer.String.Serialize(value.Version)
            };
        }

        public Schema Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            var customTypes = JsonSerializer.ReadOnlyDict(JsonSerializer.String, CustomTypeJsonSerializer.Instance).Deserialize(json["custom_types"]);
            var documentType = JsonSerializer.String.Deserialize(json["document_type"]);
            string version;
            if (json.AsObject.TryGetValue("version", out var jsonVersion) && !jsonVersion.IsNull)
                version = JsonSerializer.String.Deserialize(jsonVersion);
            else
                version = "1.0";
            return new Schema(customTypes, documentType, version);
        }

        public bool Test(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return json.IsObject;
        }
    }
}
